{"version":3,"sources":["TTTMenu.js","TTTGrid.js","TTTLabels.js","TTTController.js","TTTHelper.js","index.js"],"names":["TTTMenu","e","this","props","onTTTResize","target","value","window","confirm","onTTTRestart","options","map","index","key","id","class","onChange","bind","href","onClick","Component","TTTSquare","onClickSquare","inWinningRow","symbol","className","getClassNames","TTTGrid","winningRow","indexOf","isGridFilled","i","squares","length","classNames","rowSize","isGameOver","push","waitingMode","join","TTTLabels","user","helper","TTTController","initialRowSize","state","getStateByRowSize","helperSymbol","userSymbol","setPlayerSymbols","setState","fillSquare","setTimeout","findWinningRow","helperMoves","newSquare","getSquare","setRowSize","Array","Math","pow","fill","playerSymbol","slice","rows","allRows","row","squaresInRow","isWinningRow","newState","resizedState","resizeGame","restartGame","userMoves","TTTHelper","getMoveCount","centerPosition","getAvailableCorner","attackOrDefenseSquare","getAttackOrDefenseSquare","getRandomSquare","getDiagonalRowPattern","floor","random","userCornerIndex","corners","cornerPositions","reverse","defensiveSquare","helperSquareCount","userSquareCount","emptySquare","j","availableCorners","filter","X","O","diagonalRows","count","emptySquares","setRowCombinations","setCenterPosition","setCornerPositions","diagonalRow1","diagonalRow2","horizontalRow","verticalRow","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a478b2f9.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\n/***** secondary component: TTTMenu *****/\nclass TTTMenu extends Component {\n  onTTTResize(e) {\n    this.props.onTTTResize(e.target.value);\n  }\n  onTTTRestart() {\n    let confirmRestart = window.confirm(\"Are you sure you wish to restart this game?\");\n    if (confirmRestart) {\n      this.props.onTTTRestart();\n    }\n  }\n  render() {\n    let options = [3, 4, 5, 6].map((value, index) =>\n      <option key={index} value={value}>{value}</option>\n    );\n    return (\n      <menu id=\"TTTMenu\">\n        <menu-item class=\"resize\">\n          <select onChange={this.onTTTResize.bind(this)}>{options}</select>\n          squares per row\n        </menu-item>\n        <menu-item class=\"restart\">\n          <a href=\"#\" onClick={this.onTTTRestart.bind(this)}>Start New Game</a>\n        </menu-item>\n      </menu>\n    );\n  }\n};\n\nexport default TTTMenu;","import React, { Component } from 'react';\n\n/***** sub-component of TTTGrid: TTTSquare *****/\nclass TTTSquare extends Component {\n  onClickSquare() {\n    this.props.onClickSquare(this.props.index);\n  }\n  getClassNames() {\n    if (this.props.inWinningRow) {\n      return 'highlight frozen';\n    } else if (this.props.symbol) {\n      return 'frozen';\n    }\n    return null;\n  }\n  render() {\n    return <li className={this.getClassNames()} onClick={this.onClickSquare.bind(this)}>{this.props.symbol}</li>;\n  }\n};\n\n/***** secondary component: TTTGrid *****/\nclass TTTGrid extends Component {\n  inWinningRow(index) {\n    return (this.props.winningRow) ? (this.props.winningRow.indexOf(index) !== -1) : false;\n  }\n  isGameOver() {\n    let isGridFilled = true;\n    for (let i = 0; i < this.props.squares.length; i++) {\n      if (this.props.squares[i] === null) {\n        isGridFilled = false;\n        break;\n      }\n    }\n    return (this.props.winningRow || isGridFilled);\n  }\n  getClassNames() {\n    let classNames = ['TTTGrid-size-' + this.props.rowSize];\n    if (this.isGameOver()) {\n      classNames.push('TTTGrid-game-over frozen');\n    } else if (this.props.waitingMode) {\n      classNames.push('frozen');\n    }\n    return classNames.join(' ');\n  }\n  render() {\n    let squares = this.props.squares.map((symbol, index) =>\n      <TTTSquare\n        symbol={symbol}\n        key={index}\n        index={index}\n        inWinningRow={this.inWinningRow(index)}\n        onClickSquare={this.props.onClickSquare} />\n    );\n    return <ul id=\"TTTGrid\" className={this.getClassNames()}>{squares}</ul>;\n  }\n};\n\nexport default TTTGrid;","import React, { Component } from 'react';\n\n/***** secondary component: TTTLabels *****/\nclass TTTLabels extends Component {\n  render() {\n    return (\n      <div id=\"TTTLabels\">\n        <div>\n          <b>Player:</b> {this.props.user}\n        </div>\n        <div>\n          <b>Opponent:</b> {this.props.helper}\n        </div>\n      </div>\n    );\n  }\n};\n\nexport default TTTLabels;","import React, { Component } from 'react';\nimport TTTMenu from './TTTMenu';\nimport TTTGrid from './TTTGrid';\nimport TTTLabels from './TTTLabels';\n\nclass TTTController extends Component {\n  // component functions (for when TTT game first starts)\n  initialRowSize = 3;\n  state = this.getStateByRowSize(this.initialRowSize);\n\n  constructor(props) {\n    super(props);\n    // set custom symbols for players: \"user\" (the person playing the game) and \"helper\" (the JS object 'TTTHelper' that serves as the 'brain' of the game)\n    let helper = this.props.helperSymbol;\n    let user = this.props.userSymbol;\n    this.props.helper.setPlayerSymbols(helper, user);\n  }\n  // custom functions for player moves\n  userMoves(index) {\n    this.setState({ waitingMode: true });\n    this.fillSquare(this.props.userSymbol, index);\n    setTimeout(() => {\n      this.findWinningRow();\n      if (!this.state.winningRow) {\n        this.helperMoves();\n      }\n    }, 500);\n  }\n  helperMoves() {\n    let squares = this.state.squares;\n    let newSquare = this.props.helper.getSquare(squares);\n    this.fillSquare(this.props.helperSymbol, newSquare);\n    this.findWinningRow();\n    this.setState({ waitingMode: false });\n  }\n  // helper method to reset application state based on row size\n  getStateByRowSize(rowSize) {\n    this.props.helper.setRowSize(rowSize);\n    return {\n      rowSize: rowSize,\n      squares: Array(Math.pow(rowSize, 2)).fill(null),\n      waitingMode: false,\n      winningRow: null\n    }\n  }\n  // helper methods used by player move functions\n  fillSquare(playerSymbol, index) {\n    let squares = this.state.squares.slice();\n    squares[index] = playerSymbol;\n    this.setState({ squares: squares });\n  }\n  findWinningRow() {\n    let winningRow = null;\n    let rows = this.props.helper.allRows;\n    for (let i = 0; i < rows.length; i++) {\n      let row = rows[i];\n      let squaresInRow = row.map(index => this.state.squares[index]);\n      if (this.isWinningRow(squaresInRow)) {\n        this.setState({ winningRow: row });\n        break;\n      }\n    }\n  }\n  isWinningRow(squaresInRow) {\n    if (squaresInRow[0]) {\n      for (let i = 1; i < squaresInRow.length; i++) {\n        if (squaresInRow[i] !== squaresInRow[0]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  // helper methods to reset or resize game\n  restartGame() {\n    let newState = this.getStateByRowSize(this.state.rowSize);\n    this.setState(newState);\n  }\n  resizeGame(rowSize) {\n    let resizedState = this.getStateByRowSize(rowSize);\n    this.setState(resizedState);\n  }\n  // render the React component\n  render() {\n    return (\n      <div id=\"TTT\">\n        <TTTMenu\n          onTTTResize={this.resizeGame.bind(this)}\n          onTTTRestart={this.restartGame.bind(this)} />\n        <TTTGrid\n          rowSize={this.state.rowSize}\n          squares={this.state.squares}\n          winningRow={this.state.winningRow}\n          waitingMode={this.state.waitingMode}\n          onClickSquare={this.userMoves.bind(this)} />\n        <TTTLabels\n          user={this.props.userSymbol}\n          helper={this.props.helperSymbol} />\n      </div>\n    )\n  }\n}\n\nexport default TTTController;","class TTTHelper {\n  constructor() {\n    // default player symbols, which can be overriden using 'setPlayerSymbols' function\n    this.helper = 'O';  // 'helper' - refers to TTTHelper, the JS object that serves as the 'brain' of the game\n    this.user   = 'X';  // 'user' - refers to the human opponent playing the game\n  }\n  /*** determine which square the Helper will pick, based on the array of squares passed to it ***/\n  getSquare(squares) {\n    /*\n      This object was initially created with:\n      (1) the assumption that this game would always be 3x3, and\n      (2) the requirement that the user will never beat the game (played by a JS object known as 'TTTHelper').\n\n      For this newly-revised TTTDeluxe web app, the row size can be anywhere from 3 to 6 squares.\n      For 3x3 games, I have preserved the original algorithm that prevents TTTHelper from ever losing,\n      but I was not asked to keep this requirement for larger grids.  That said, I have implemented some\n      degree of reasoning for determining TTTHelper's moves for larger grids.\n\n      Algorithms for 3x3 strategy taken from this URL:\n      https://www.quora.com/Is-there-a-way-to-never-lose-at-Tic-Tac-Toe/answer/Arjun-Subramaniam\n\n      Assumption: the user always goes first.\n    */\n    this.squares = squares;\n\n    /* first move */\n    if (this.getMoveCount() === 0) {\n      if (this.centerPosition && !squares[this.centerPosition]) {\n        return this.centerPosition;  // if there is a center square and the user hasn't already taken it, grab the center\n      } else {\n        return this.getAvailableCorner(); // if the user has already taken the center or there is no center square, take an available corner\n      }\n    }\n    /* second move */\n    else if (this.getMoveCount() === 1) {\n      /* to block the user from a win... */\n      let attackOrDefenseSquare = this.getAttackOrDefenseSquare();\n      if (attackOrDefenseSquare !== null) {\n        return attackOrDefenseSquare;  // take whatever square you need to block the user\n      }\n      /* for 3x3 only: check for diagonal patterns and select a square based on pattern */\n      else if (this.rowSize === 3) {\n        switch(this.getDiagonalRowPattern()) {\n          case 'XOX':\n            let edges = [1, 3, 5, 7];\n            let index = Math.floor(Math.random() * 4);\n            return edges[index];  // take an edge square\n          case 'XXO':\n            return this.getAvailableCorner(); // take an available corner\n          case 'XO_':\n            let userCornerIndex;\n            let corners = this.cornerPositions;\n            for (let i = 0; i < corners.length; i++) {\n              if (this.squares[corners[i]] === this.user) {\n                userCornerIndex = i;\n                break;\n              }\n            }\n            return corners.reverse()[userCornerIndex]; // take the opposite corner from the user\n          default:\n            return this.getRandomSquare();  // take a random available square\n        }\n      }\n      /* for grids larger than 3x3: take any available corner */\n      else {\n        return this.getAvailableCorner();\n      }\n    }\n    /* subsequent moves */\n    else {\n      let attackOrDefenseSquare = this.getAttackOrDefenseSquare();\n      return (attackOrDefenseSquare !== null) ? attackOrDefenseSquare : this.getRandomSquare();  // check to see if you can attack or need to defend - if not, then take random square\n    }\n  }\n  /*** choose square based on whether there's an opportunity to fill the whole row, or a need to block the user from filling the row ***/\n  getAttackOrDefenseSquare() {\n    let defensiveSquare = null;\n    for (let i in this.allRows) {\n      let helperSquareCount = 0, userSquareCount = 0, emptySquare = null;\n      let row = this.allRows[i];\n      let squaresInRow = row.map((index) => this.squares[index]);\n      for (let j = 0; j < squaresInRow.length; j++) {\n        if (squaresInRow[j] === this.helper) { helperSquareCount++; }\n        if (squaresInRow[j] === this.user) { userSquareCount++; }\n        if (squaresInRow[j] === null) { emptySquare = row[j]; }\n      }\n      // if the helper has almost filled a row and the last square is empty...\n      if (helperSquareCount === (row.length - 1) && userSquareCount === 0) {\n        return emptySquare;  // ...take that square immediately and win the game\n      }\n      // if the user has almost filled a row and the last is empty...\n      else if (helperSquareCount === 0 && userSquareCount === (row.length - 1)) {\n        defensiveSquare = defensiveSquare || emptySquare;  // hang on to that square and use it only when we've confirmed there's no winning move\n      }\n    }\n    return defensiveSquare;\n  }\n  /*** choose an available corner square ***/\n  getAvailableCorner() {\n    let availableCorners = this.cornerPositions.filter((index) => (this.squares[index] === null));\n    let index = Math.floor(Math.random() * availableCorners.length);\n    return availableCorners[index]; // take an available corner\n  }\n  /*** FOR 3x3 GAMES ONLY: when Helper is on its second move, check for diagonal pattern ***/\n  getDiagonalRowPattern() {\n    let X = this.user, O = this.helper;\n    let diagonalRows = this.diagonalRows;\n    for (let i = 0; i < diagonalRows.length; i++) {\n      let squaresInRow = diagonalRows[i].map((index) => this.squares[index] );\n      // check for \"XOX\" diagonal (where X = user, O = helper)\n      if (squaresInRow[0] === X && squaresInRow[1] === O && squaresInRow[2] === X) {\n        return 'XOX';\n      }\n      // check for \"XXO/OXX\" diagonal (where X = user, O = helper)\n      else if ((squaresInRow[0] === X && squaresInRow[1] === X && squaresInRow[2] === O) ||\n        (squaresInRow[0] === O && squaresInRow[1] === X && squaresInRow[2] === X)) {\n        return 'XXO';\n      }\n      // check for \"_OX/XO_\" diagonal (where X = user, O = helper)\n      else if ((squaresInRow[0] === null && squaresInRow[1] === O && squaresInRow[2] === X) ||\n        (squaresInRow[0] === X && squaresInRow[1] === O && squaresInRow[2] === null)) {\n        return 'XO_';\n      }\n    }\n    return null;\n  }\n  /*** how many moves the Helper has made already ***/\n  getMoveCount() {\n    let count = 0;\n    for (let index in this.squares) {\n      if (this.squares[index] === this.helper) {\n        count++;\n      }\n    }\n    return count;\n  }\n  /*** choose any random available square ***/\n  getRandomSquare() {\n    let emptySquares = [];\n    for (let i = 0; i < this.squares.length; i++) {\n      if (this.squares[i] === null) {\n        emptySquares.push(i);\n      }\n    }\n    let random = Math.floor(Math.random() * emptySquares.length);\n    return emptySquares[random];\n  }\n  /*** override default helper and user symbols with custom symbols if applicable ***/\n  setPlayerSymbols(helper, user) {\n    this.helper = helper;\n    this.user = user;\n  }\n  /*** update TTTHelper based on row size ***/\n  setRowSize(rowSize) {\n    this.rowSize = rowSize;\n    this.setRowCombinations();\n    this.setCenterPosition();\n    this.setCornerPositions();\n  }\n  /*** set row combinations ***/\n  setRowCombinations() {\n    let rowSize = this.rowSize;\n    let allRows = [], diagonalRow1 = [], diagonalRow2 = [];\n    for (let i = 0; i < rowSize; i++) {\n      // get horizontal and vertical rows\n      let horizontalRow = [], verticalRow = [];\n      for (let j = 0; j < rowSize; j++) {\n        horizontalRow.push(j + (i * rowSize));\n        verticalRow.push(i + (j * rowSize));\n      }\n      allRows.push(horizontalRow);\n      allRows.push(verticalRow);\n      // diagonal rows\n      diagonalRow1.push(i + (rowSize * i));\n      diagonalRow2.push( (rowSize - 1) * (i + 1) );\n    }\n    allRows.push(diagonalRow1);\n    allRows.push(diagonalRow2);\n    // set row properties\n    this.allRows = allRows;\n    this.diagonalRows = [diagonalRow1, diagonalRow2];\n  }\n  /*** set center position index ***/\n  setCenterPosition() {\n    if (this.rowSize % 2 === 1) {\n      this.centerPosition = Math.floor(Math.pow(this.rowSize, 2)/2);\n    } else {\n      this.centerPosition = null;\n    }\n  }\n  /*** set corner position indices ***/\n  setCornerPositions() {\n    this.cornerPositions = [\n      0,\n      this.rowSize - 1,\n      Math.pow(this.rowSize, 2) - this.rowSize,\n      Math.pow(this.rowSize, 2) - 1\n    ];\n  }\n}\n\nexport default TTTHelper;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport TTTController from './TTTController';\nimport TTTHelper from './TTTHelper';\n\nReactDOM.render(<TTTController userSymbol='X' helperSymbol='O' helper={new TTTHelper()} />,\n  document.getElementById('main')\n);\n"],"sourceRoot":""}